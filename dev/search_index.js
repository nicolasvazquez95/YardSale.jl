var documenterSearchIndex = {"docs":
[{"location":"tutorials/ode_systems/ode_systems/#Import-necessary-packages","page":"ODE systems","title":"Import necessary packages","text":"","category":"section"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"using DifferentialEquations, Graphs\nusing YardSale\nusing Plots, LaTeXStrings, ColorSchemes","category":"page"},{"location":"tutorials/ode_systems/ode_systems/#Description-of-the-model","page":"ODE systems","title":"Description of the model","text":"","category":"section"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"Here we're going to use the functionalities of the ODE solver implemented in YardSale.jl. These are simple functions that wrap the DifferentialEquations.jl package to solve the ODE systems we're interested in. By wrapping, we are allowed to explore efficiently the parameters space.","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"The models we're going to explore belong to a wider class of models called Asset Exchange Models. These are models inspired in the statistical physics of interacting particles. The main idea is that agents exchange assets in a network, just like particles exchange energy in a physical system. The dynamics of the system is given by the exchange rules, which usually involve binary transactions. For a review of these models, see for example Greenberg, M., Gao, H.O. Twenty-five years of random asset exchange modeling. Eur. Phys. J. B 97, 69 (2024) DOI.","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"Here, we're studying specifically and ODE approximation of one of these models, called the \"Extended Yard-Sale Model\" (EYSM), published in Boghosian et al. (2017). Physica A, 476, 15-42 DOI. For details on the derivation of the equations please refer to our original paper.","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"Given a network a, the model is defined by the following set of ODEs:","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"dotx_i = fracTN bigg(-beta_i x_i+frac1Nsum_j beta_j x_jbigg) + sum_jkappa_ij(x_i-x_jmin(x_ix_j)","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"where x_i represents the (expected) relative wealth of agent i, and T represents the temperature. The parameters beta_i and kappa_ij are parameters which contain information about the network structure of a, and the way in which agents get taxed and interact with each other, respectively.","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"As described in the original paper, the EYSM exhibits a second-order phase transition as a function of the temperature T when the network is a complete graph. This transition is characterized by the emergence of an oligarchy at low temperatures, where a few agents accumulate most of the wealth. At high temperatures, the wealth is more evenly distributed among the agents. The transition is characterized by the order parameter x_1 (the wealth of the richest agent) as a function of the temperature T. In the thermodynamic limit, the order parameter behaves as","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"x_1(T) = begincases\n        1 - T  textif  T leq 1 \n        0  textif  T  1endcases","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"In this notebook, we're going to reproduce the phase transition of the EYSM in a complete graph, using the implementation of the ODE solver in YardSale.jl.","category":"page"},{"location":"tutorials/ode_systems/ode_systems/#1.-A-first-look-at-the-model","page":"ODE systems","title":"1. A first look at the model","text":"","category":"section"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"Let's study the time evolution of the wealth distribution in the original EYSM. We'll set a system of few agents, and we'll plot the wealth of all agents as a function of time.","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"# Number of nodes\nN = 16\n# A complete graph with N nodes (Graphs.jl)\ng = complete_graph(N)\n# Interaction and taxation modes\ninteraction_mode = \"A\"\ntaxation_mode = \"A\"\n# Temperature\nT = 1.0\n# Time span\ntspan = (0.0, 30000)\ndt = 10\n# Seed\nseed = 42\n# Initial conditions\ninitial_conditions = \"noisy\" # Defaul, but you can also use \"random\", \"custom\", or \"uniform\"\n;","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"# Solve the system\nsol = solve_ode_net(\n    g,\n    tspan,\n    interaction_mode,\n    taxation_mode,\n    T,\n    seed;\n    integrator = Tsit5(),\n    initial_conditions = initial_conditions,\n    saveat = dt\n)\n;","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"# Get the time series of the state variables, sorted by final state\nx_t = hcat(sol.u...)'[:, sortperm(sol.u[end])]","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"3001×16 Matrix{Float64}:\n 0.0611785  0.0615817  0.0619628  …  0.0630102  0.0630252  0.0634045\n 0.0611742  0.0615783  0.0619606     0.0630128  0.0630278  0.0634091\n 0.0611699  0.0615749  0.0619584     0.0630154  0.0630305  0.0634137\n 0.0611656  0.0615715  0.0619563     0.063018   0.0630332  0.0634184\n 0.0611612  0.0615681  0.0619541     0.0630206  0.0630359  0.063423\n 0.0611569  0.0615646  0.0619519  …  0.0630232  0.0630386  0.0634277\n 0.0611526  0.0615612  0.0619497     0.0630258  0.0630413  0.0634324\n 0.0611482  0.0615577  0.0619475     0.0630285  0.063044   0.0634371\n 0.0611438  0.0615543  0.0619452     0.0630311  0.0630467  0.0634418\n 0.0611395  0.0615508  0.061943      0.0630338  0.0630495  0.0634466\n 0.0611351  0.0615473  0.0619408  …  0.0630365  0.0630522  0.0634513\n 0.0611307  0.0615438  0.0619385     0.0630392  0.063055   0.0634561\n 0.0611263  0.0615403  0.0619363     0.0630419  0.0630578  0.063461\n ⋮                                ⋱                        ⋮\n 0.0585937  0.0585937  0.0585937     0.058595   0.0585952  0.119949\n 0.0585937  0.0585937  0.0585937  …  0.058595   0.0585952  0.119949\n 0.0585937  0.0585937  0.0585937     0.058595   0.0585952  0.119949\n 0.0585937  0.0585937  0.0585937     0.058595   0.0585952  0.119949\n 0.0585937  0.0585937  0.0585937     0.058595   0.0585952  0.119949\n 0.0585937  0.0585937  0.0585937     0.058595   0.0585952  0.119949\n 0.0585937  0.0585937  0.0585937  …  0.058595   0.0585952  0.119949\n 0.0585937  0.0585937  0.0585937     0.0585949  0.0585952  0.119949\n 0.0585937  0.0585937  0.0585937     0.0585949  0.0585952  0.119949\n 0.0585937  0.0585937  0.0585937     0.0585949  0.0585952  0.119949\n 0.0585937  0.0585937  0.0585937     0.0585949  0.0585952  0.119949\n 0.0585937  0.0585937  0.0585937  …  0.0585949  0.0585951  0.119949","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"# Rescale the time units to MC steps\nt_mcs = rescale_t(sol.t,N)\n;","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"# Make the paper plot\np = plot(\n    ylabel = L\"x_i\",\n    xlabel = L\"t\"*\" [\"*L\"10^{4}\\;\\mathrm{MC\\;steps}]\",\n    fontfamily = \"Computer Modern\",\n    legend_title = \"ODE - Wealth distribution\",\n    xguidefontsize = 17,\n    yguidefontsize = 17,\n    legendfontsize = 15,\n    legendtitlefontsize = 16,\n    xtickfontsize = 17,\n    ytickfontsize = 17,\n    palette = :tol_nightfall,\n    size=(640,480),\n    fmt=:png,\n    ylims = (:auto, 0.13),\n    xlims = (0,:auto),\n    minorticks = true\n)\n\nfor i in 1:N\n    plot!(t_mcs ./ 1e4, x_t[:, i], label = \"\", lw = 2)\nend\n\ndisplay(p)","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"(Image: Time evolution of the system)","category":"page"},{"location":"tutorials/ode_systems/ode_systems/#2.-Wealth-of-the-richest-agent-as-a-function-of-the-temperature-(order-parameter)","page":"ODE systems","title":"2. Wealth of the richest agent as a function of the temperature (order parameter)","text":"","category":"section"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"Next, we'd like to see the phase transition looking at the plot of the wealth of the richest agent x_1 as a function of the temperature T. We must run the simulation at different temperatures, record the wealth of the richest agent at the end of the simulations. We'll then plot the wealth of the richest agent as a function of the temperature. Notice that the simulations have an transient period, so we must run the simulations for a long enough time to ensure that the system has reached the steady state. For our purposes, a t_textmax = 10^7 should be enough. In any case, as we're not interested in intermediate times, we'll use a different solver, provided by the DifferentialEquations.jl package, which can search for the steady state of the system. That is what the solve_ode_net_SS function does.","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"We must increase the default tolerance of the integrator, because the system has critical behavior near the phase transition. We'll set the tolerante to 10^-15.","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"# The system has to be big enough to discard finite size effects\nN = 128\ng = complete_graph(N)\n# Interacion and taxation modes\ninteraction_mode = \"A\"\ntaxation_mode = \"B\"\n# Time span\ntspan = (0.0, 1e7)\n# Different temperatures\ntemperatures = 0.0:0.05:2.0\n# Seed\nseed = 42","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"42","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"# Run simulations\nx1_T = zeros(length(temperatures))\n# Solve the system for different temperatures\nfor (i,T) in enumerate(temperatures)\n    sol = solve_ode_net_SS(\n        g,\n        interaction_mode,\n        taxation_mode,\n        T,\n        seed;\n        integrator = Tsit5(),\n        initial_conditions = initial_conditions,\n        reltol=1e-15,\n        abstol=1e-15\n    )\n    x1_T[i] = maximum(sol.u)\nend","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"p2 = plot(\n    ylabel = L\"x_1\",\n    xlabel = L\"T\",\n    fontfamily = \"Computer Modern\",\n    legend_title = \"ODE: \" * L\"x_1\" * \" vs \" * L\"T\",\n    xguidefontsize = 17,\n    yguidefontsize = 17,\n    legendfontsize = 15,\n    legendtitlefontsize = 16,\n    xtickfontsize = 17,\n    ytickfontsize = 17,\n    palette = :julia,\n    size=(640,480),\n    fmt=:png,\n    minorticks = true\n)\n\np = scatter!(\n    p2,\n    temperatures,\n    x1_T,\n    label = L\"N=\"*\"$N\",\n    ms = 5,\n    color = 1\n    )\n\np2 = plot!(p2,temperatures[1:21], x1_T[1:21], label=L\"x_1 = 1 - T\", lw = 2,ls=:dot,color=2)\np2 = hline!(p2,[1/N],label=L\"x_1 = 1/N\",lw=2,ls=:dot,color=3)","category":"page"},{"location":"tutorials/ode_systems/ode_systems/","page":"ODE systems","title":"ODE systems","text":"(Image: x_1 vs. T)","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/#Import-necessary-packages","page":"EYSM in Networks","title":"Import necessary packages","text":"","category":"section"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"using Pkg; Pkg.activate(\".\")\nusing YardSale, Graphs\nusing Plots, GraphRecipes, LaTeXStrings\nusing ProgressMeter, JLD2\nusing Statistics","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"In this notebook, we will explore some of the functionalities implemented for the Monte Carlo simulations in the YardSale.jl package. We'll describe how to run simulations in arbitrary networks, using different taxation and interaction schemes, and briefly discuss the results obtained.","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/#Build-a-graph-using-the-Graphs.jl-package","page":"EYSM in Networks","title":"Build a graph using the Graphs.jl package","text":"","category":"section"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"# Instantiate a graph\nN = 64\n# Expected mean degree\nk_mean = 16 \n# Erdos-Renyi graph, seed = 42\ng = erdos_renyi(N, k_mean/(N-1), seed=42)","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"{64, 524} undirected simple Int64 graph","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"# Plot the graph\np1 = graphplot(\n    g,\n    markersize=0.15,\n    markershape=:circle,\n    edgelinewidth=0.1,\n    linealpha=0.5,\n    size=(400, 400),\n    title=\"Erdos-Renyi graph\",\n)\n\n# Plot the degree distribution\np2 = histogram(degree(g), bins=0:1:maximum(degree(g)), normed=true,\n                label=\"Degree distribution\",xlabel=\"k\",ylabel=\"P(k)\",\n                legend=:topleft)\np = plot(p1, p2, layout=(1,2), size=(800, 400))","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"(Image: Graph info)","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"Over this network, we will run a Monte Carlo simulation of our generalized version of the Extended Yard-Sale Model. In this generalization, we specify an interaction mode for the agents (defining the way they exchange wealth) and a taxation mode (defining the way the government collects taxes and redistributes wealth). The interaction modes available are:","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"Interaction Mode A: At each time step, a random link is chosen at random.\nInteraction Mode B: At each time step, a random agent and one of its neighbors are chosen at random.","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"The taxation modes available are:","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"Taxation Mode A: At each time step, The agents who exchange wealth pay taxes.\nTaxation Mode B: Two agents at random are chosen to pay taxes. The redistribution ocurrs homogeneously, i.e., the total amount of taxes collected is redistributed equally among all agents.","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"The idea is to explore the effects of different interaction and taxation modes on the wealth distribution of the agents, at different temperatures.","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/#Run-the-simulations","page":"EYSM in Networks","title":"Run the simulations","text":"","category":"section"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"# Parameters \n# Mean wealth\nW_N = 1.0f0\nchi = 0.15f0\nzeta = 1.0f0\nf = 0.01f0\n# Interaction modes\nIM = [\"A\",\"B\"]\n# Taxation modes\nTM = [\"A\",\"B\"]\nseed = 42\nsteps = 20000 * N\n;","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"# This cell may take a while to run...\nresults = Dict()\nfor interaction_mode in IM\n    for taxation_mode in TM\n        println(\"Running simulation for IM$(interaction_mode), TM$(taxation_mode)\")\n        # Run the simulation\n        res = EYSM_net_full(g, W_N, interaction_mode, taxation_mode,\n        chi, zeta, f, steps, seed)\n        results[\"$(interaction_mode),$(taxation_mode)\"] = res\n    end\nend","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"Running simulation for IMA, TMA\nRunning simulation for IMA, TMB\nRunning simulation for IMB, TMA\nRunning simulation for IMB, TMB","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"# Save the results\nsave(\"eysm_net_base.jld2\", \"results\", results)\n;","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"# Load the results (if needed)\n#using JLD2\n#results = load(\"eysm_net_base.jld2\")[\"results\"]","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"Dict{Any, Any} with 4 entries:\n  \"B,A\" => Float32[1.0 1.0 … 1.0 1.0; 0.847615 0.870765 … 0.995251 1.08111; … ;…\n  \"B,B\" => Float32[1.0 1.0 … 1.0 1.0; 1.05025 0.88395 … 1.03223 0.882832; … ; 0…\n  \"A,B\" => Float32[1.0 1.0 … 1.0 1.0; 1.0417 1.11445 … 0.877517 0.903814; … ; 0…\n  \"A,A\" => Float32[1.0 1.0 … 1.0 1.0; 1.11878 1.12205 … 0.889989 0.913464; … ; …","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"# Plot the results for the different scenarios\nx1 = Dict()\nfor (key, value) in results\n    x1[key] = get_x1(value)\nend\n\np = plot(\n    fontfamily=\"Computer Modern\",\n    xlabel=L\"t\",\n    ylabel=L\"x_1\",\n    palette=:julia,\n    minorticks=true,\n    legend_title = \"Interaction/Taxation mode\",\n    xguidefontsize = 12,\n    yguidefontsize = 12,\n    legendfontsize = 11,\n    legendtitlefontsize = 12,\n    xtickfontsize = 12,\n    ytickfontsize = 12,\n)\n\nfor interaction_mode in IM\n    for taxation_mode in TM\n        key = \"$(interaction_mode),$(taxation_mode)\"\n        label = \"IM$(interaction_mode)/TM$(taxation_mode)\"\n        plot!(p, x1[key], label=label,lw=3)\n    end\nend\n\ndisplay(p)","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"(Image: Time evolution for different interaction/taxation modes)","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/#Equivalence-of-the-4-combinations-of-interaction-and-taxation-modes-for-fully-connected-networks","page":"EYSM in Networks","title":"Equivalence of the 4 combinations of interaction and taxation modes for fully connected networks","text":"","category":"section"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"We want to make this test for 2 reasons:","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"To check if the implementation is correct\nTo demonstrate the equivalence of our theoretical model with the original one by Boghosiant et al. (2017) in the case of fully connected networks.","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"To do this, we will run 4 sets of simulations, one for each combination of interaction and taxation modes, in a fully connected network. We will then compare the results obtained. For each combination, we will run 1 simulation at each temperature value in the range 0:0.1:3. Then in the steady state we'll measure the value of x_1 and finally plot the x_1 vs. T curves for each interaction/taxation mode.","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"# Graph parameters\nN = 64\n# Probability of connection (1 for a fully connected graph)\np = 1.0\ng = erdos_renyi(N, p,seed=42)\n\n# Simulation parameters\nW_N = 1.0f0\nchi = 0.0f0:0.1f0:3.0f0\nzeta = 1.0f0\nf = 0.01f0\nsteps = 40000 * N \nseed = 42\nIM = [\"A\",\"B\"]\nTM = [\"A\",\"B\"]\n;","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"# This cell may take a while to run...\n\nresults = Dict()\n\nfor interaction_mode in IM\n    for taxation_mode in TM\n        println(\"Running simulations for IM$(interaction_mode), TM$(taxation_mode)\")\n        im_tm = []\n        @showprogress for c in chi\n            res_c = EYSM_net_full(g, W_N, interaction_mode, taxation_mode,\n            c, zeta, f, steps, seed)\n            push!(im_tm, get_x1(res_c))\n        end\n        results[\"$(interaction_mode),$(taxation_mode)\"] = im_tm\n    end\nend\n\n# Save the results\nsave(\"eysm_net_chi.jld2\", \"results\", results)","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"# Load the results (if needed)\n#using JLD2\n#results = load(\"eysm_net_chi.jld2\")[\"results\"]","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"Dict{Any, Any} with 4 entries:\n  \"B,A\" => Any[Float32[1.0; 1.22125; … ; 64.0; 64.0;;], Float32[1.0; 1.22054; ……\n  \"B,B\" => Any[Float32[1.0; 1.21331; … ; 64.0; 64.0;;], Float32[1.0; 1.21311; ……\n  \"A,B\" => Any[Float32[1.0; 1.22679; … ; 64.0; 64.0;;], Float32[1.0; 1.22648; ……\n  \"A,A\" => Any[Float32[1.0; 1.20624; … ; 64.0; 64.0;;], Float32[1.0; 1.20611; ……","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"# Process the results\n# Index of the time step where the system reaches a steady state \n# (can be checked by plotting)\n\nsteady_state = 20000\nx1 = Dict()\nfor taxation_mode in TM\n    for interaction_mode in IM\n        x1_imtm = []\n        for c in 1:length(chi)\n            key = \"$(interaction_mode),$(taxation_mode)\"\n            push!(x1_imtm, mean(results[key][c][steady_state:end])/N)\n        end\n        x1[\"$(interaction_mode),$(taxation_mode)\"] = x1_imtm\n    end\nend","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"# Plot the results\np = plot(\n    fontfamily=\"Computer Modern\",\n    xlabel=L\"T\",\n    ylabel=L\"x_1\",\n    palette=:julia,\n    minorticks=true,\n    legend_title = \"Interaction/Taxation mode\",\n    xguidefontsize = 12,\n    yguidefontsize = 12,\n    legendfontsize = 11,\n    legendtitlefontsize = 12,\n    xtickfontsize = 12,\n    ytickfontsize = 12,\n)\n\nmarkers = [:circle, :square, :diamond, :cross]\nmarker_idx = 1\nfor interaction_mode in IM\n    for taxation_mode in TM\n        key = \"$(interaction_mode),$(taxation_mode)\"\n        label = \"IM$(interaction_mode)/TM$(taxation_mode)\"\n        scatter!(p, chi ./ zeta, x1[key], label=label,ms=6,markershape=markers[marker_idx])\n        marker_idx += 1\n    end\nend\ndisplay(p)","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"(Image: Equivalence of the 4 combinations of interaction and taxation modes for fully connected networks)","category":"page"},{"location":"tutorials/mc_eysm_net/mc_eysm_net/","page":"EYSM in Networks","title":"EYSM in Networks","text":"As we can see, all the interaction/taxation modes yield the same results, as expected. This is because in a fully connected network, the agents are all equivalent, and the interaction and taxation modes do not affect the wealth distribution. This is a good test to check if the implementation is correct.","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/#Import-necessary-packages","page":"EYSM Base","title":"Import necessary packages","text":"","category":"section"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"using YardSale\nusing Plots, Measures, LaTeXStrings, ColorSchemes","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/#Description-of-the-notebook","page":"EYSM Base","title":"Description of the notebook","text":"","category":"section"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"In this notebook we'll explore the behavior of the Extended Yard-Sale Model (EYSM), simulating the (stochastic) evolution of an economical systems of N agents. These agents are characterized by their wealth w_i i=1N. The rules of the model have been described in the ode_systems.ipynb notebook.  Here, we add the stochasticity to the model, in the framework of Monte Carlo simulations. With this addition, we expect to see not only the phase transition of the model, but also the fluctuations around the critical point. ","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"Remember that the exchange rule of the EYSM is given by:","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"Delta w_ij = chi Delta t bigg(fracWN - w_ibigg) + eta_ij sqrtgamma Delta t min(w_iw_j)","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"where chi is the redistribution rate, sqrtgamma Delta t represents the fraction f of the wealth that is exchanged between agents i and j at each time step, and eta_ij is a random number that can be pm 1. This stochastic variable has the properties","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"langle eta_ij rangle = zeta N sqrtfracDelta tgamma frac(w_i - w_j)W qquad langle eta_ij^2 rangle = 1","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"The parameter zeta represents the Wealth-Attained Advantage (WAA) parameter, which is a bias that favors the richer agent in the exchange. Finally, the wealth of the agents is updated as","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"w_i to w_i + Delta w_ij qquad w_j to w_j - Delta w_ij","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"In this notebook, we''ll explore the behavior of the EYSM model using Monte Carlo simulations. We''ll study the dynamics and the phase transition of the model measuring the order parameter and its fluctuations at the steady state.","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/#1.-Time-evolution-of-the-wealth-distribution","page":"EYSM Base","title":"1. Time evolution of the wealth distribution","text":"","category":"section"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"For a small system, we can visualize the evolution of the wealth of each agent over time.","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"# Parameters of the system\nN = 16\nW_N = 1.0\n\n# Temperature of the system: χ/ζ\nchi = 1.0\nzeta = 1.0\n\n# The fraction of exchange determines in some way the intensity of the noise,\n# Larger values of f will speed up the system, but it will also make the noise\n# more intense, an the dynamics will be less smooth. \n# I found that f < 0.1 is a rule of thumb.\nf = 0.01\n\n# Steps to run the simulation\nsteps = 10000 # MC steps\n# Seed\nseed = 42 # The answer to the ultimate question of life, the universe and everything\n\n# Optional\nsave_every = 1 \n;","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"# Run \n@time w_t = EYSM_base_full(N, W_N, chi, zeta, f, steps, seed; save_every=save_every)\n\n# Sort the columns according to the final state\nw_t = w_t[:,sortperm(w_t[end,:])]","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"  0.026488 seconds (350.02 k allocations: 14.344 MiB)\n10001×16 Matrix{Float64}:\n 1.0       1.0       1.0       1.0       …  1.0       1.0       1.0\n 1.00988   1.00011   0.990101  1.01         0.990199  1.0       1.01979\n 1.00988   0.999997  0.970359  0.989991     0.990195  0.999996  1.02948\n 1.02985   0.980294  0.980077  0.999894     0.970505  0.989931  1.04963\n 1.01964   0.970732  0.979959  0.999896     0.970441  0.989934  1.04964\n 1.00953   1.00018   0.979958  1.02938   …  0.960755  0.999838  1.02978\n 0.999528  0.981201  0.989694  1.02911      0.97039   1.01993   1.02015\n 0.999133  0.971524  1.00831   1.02907      0.960703  1.0204    1.02003\n 0.989324  0.99047   0.998984  1.03846      0.97033   1.03038   1.03996\n 0.979914  0.990466  0.998689  1.02873      0.950995  1.04025   1.03979\n 0.969973  0.990473  0.979881  1.01851   …  0.950961  1.0313    1.03885\n 0.970002  0.98056   0.960972  1.00877      0.970246  1.04145   1.02892\n 0.969923  0.970407  0.98012   1.00876      0.970233  1.07141   1.01859\n ⋮                                       ⋱                      ⋮\n 0.440844  0.552208  0.643806  0.75115      1.56723   1.76156   1.9168\n 0.445601  0.547458  0.646276  0.743793  …  1.56723   1.73571   1.89882\n 0.450387  0.559005  0.652935  0.751363     1.54405   1.74003   1.89271\n 0.451083  0.582863  0.659337  0.73784      1.56042   1.74721   1.8839\n 0.448141  0.582775  0.652858  0.730516     1.59655   1.74695   1.8786\n 0.45294   0.571665  0.653567  0.736467     1.57927   1.76105   1.8678\n 0.452921  0.555469  0.647222  0.757503  …  1.57921   1.75976   1.85909\n 0.448712  0.555443  0.648287  0.757467     1.5646    1.78162   1.87482\n 0.440498  0.561309  0.642063  0.757512     1.57233   1.78772   1.86648\n 0.436412  0.555931  0.642407  0.757888     1.59429   1.76861   1.84066\n 0.428482  0.567727  0.642484  0.76592      1.58645   1.77934   1.84088\n 0.42847   0.579662  0.612112  0.765899  …  1.58641   1.77612   1.83163","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"p1 = plot(\n    ylabel = L\"x_i\",\n    xlabel = L\"t\"*\" [MC steps]\",\n    fontfamily = \"Computer Modern\",\n    legend_title = \"MC - Wealth distribution\",\n    xguidefontsize = 17,\n    yguidefontsize = 17,\n    legendfontsize = 15,\n    legendtitlefontsize = 17,\n    xtickfontsize = 17,\n    ytickfontsize = 17,\n    palette = :tol_nightfall,\n    size=(640,480),\n    fmt=:png,\n    ylims = (0, 0.23),\n    xlims = (0,:auto),\n    minorticks = true,\n    right_margin = 8mm,\n    legend = :topright,\n)    \n\nfor i in 1:N\n    plot!(p1,w_t[:,i]/N, label = \"\", lw = 2)\nend\n\ndisplay(p1)","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"(Image: MC time evolution)","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/#2.-Phase-transition-properties","page":"EYSM Base","title":"2. Phase transition properties","text":"","category":"section"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"Now, we would like to study the phase transition of the model. For that, we need to make some statistics over a certain number of realizations of the model. Then we can calculate the order parameter and its fluctuations. In Julia, we can use the Threads.@threads macro to parallelize the independent simulations. This will speed up the calculations. Then the order parameter and its fluctuations can be calculated with the Statistics.jl package.","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"using ProgressMeter","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"# Number of runs\nN = 64\nW_N = 1.0f0\nzeta = 1.0f0\nchi = 0.0f0:0.04f0:2.0f0\nsteps = 30000 * N # MC steps: 30000 * 128 = 3.84e6\nseed = 42\n# Run\nsims = zeros(typeof(W_N), length(chi), (steps ÷ N) + 1, N)\n\n# Safe lock \nlk = ReentrantLock()\n# ProgressMeter\np = Progress(length(chi), showspeed=true)\nThreads.@threads for i in 1:length(chi)\n    w_t = EYSM_base_full(N, W_N, chi[i], zeta, f, steps, seed)\n    lock(lk) do \n        sims[i,:,:] = w_t\n        next!(p)\n    end\nend\n\n# Save with JLD2\n#using JLD2\n#save(\"sims.jld2\", \"sims\", sims)\n# Load with JLD2\n#sims = load(\"sims.jld2\")[\"sims\"]","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"Now at each temperature, we can calculate the mean value of the order parameter and its fluctuations using simple statistics.","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"# Each row is x1(T,t) for a given T=χ/ζ\nx1 = dropdims(maximum(sims,dims=3),dims=3)\n# Calculate mean and variance for all temperatures, in the steady state\nusing Statistics\nstart = 20000\nmean_x1 = mean(x1[:,start:end]/N,dims=2)\nvar_x1 = var(x1[:,start:end]/N,dims=2)\n;","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"p1 = plot(\n    ylabel = L\"x_1\",\n    xlabel = L\"T\",\n    fontfamily = \"Computer Modern\",\n    xguidefontsize = 17,\n    yguidefontsize = 17,\n    legendfontsize = 15,\n    legendtitlefontsize = 17,\n    xtickfontsize = 17,\n    ytickfontsize = 17,\n    minorticks = true,\n    palette = :julia,\n    size=(640,480),\n    y_foreground_color_text = ColorSchemes.julia[1],\n    y_foreground_color_axis = ColorSchemes.julia[1]\n)\n\nscatter!(p1, chi /zeta, mean_x1, yerr=sqrt.(var_x1),label=\"MC, \" *L\"N=\"*\"$N\",ms=5)\np2 = twinx(p1)\nscatter!(\n    p2,\n    chi /zeta, \n    1e4*var_x1, \n    label=\"\",\n    ms=5,\n    palette=:julia,\n    color=2,\n    minorticks=true,\n    ylabel=L\"\\sigma^2(x_1)\\,[\\,\\times 10^{-4}]\",\n    yguidefontsize = 17,\n    ytickfontsize = 17,\n    y_foreground_color_text = ColorSchemes.julia[2],\n    y_foreground_color_axis = ColorSchemes.julia[2]\n    )","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"(Image: MC phase transition)","category":"page"},{"location":"tutorials/mc_eysm_base/mc_eysm_base/","page":"EYSM Base","title":"EYSM Base","text":"As it can be seen, the two curves are consistent, and the order parameter shows a clear phase transition. The fluctuations of the order parameter are also shown, and they are maximum around the critical point.","category":"page"},{"location":"references/utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"references/utils/","page":"Utils","title":"Utils","text":"Additional functions for the functionalities of the package.","category":"page"},{"location":"references/utils/","page":"Utils","title":"Utils","text":"Modules = [YardSale]\nPages = [\"utils/kappa_beta.jl\",\"utils/mc_auxiliary_functions.jl\",\"utils/ode_auxiliary_functions.jl\",\"utils/graph_functions.jl\",\"utils/mf_functions.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"references/utils/#YardSale.get_kappa_beta-Tuple{Graphs.SimpleGraphs.SimpleGraph, String, String}","page":"Utils","title":"YardSale.get_kappa_beta","text":"get_kappa_beta(g::SimpleGraph{<:Integer},interaction_mode::String,taxation_mode::String)\n\nReturn the κ matrix and the β vector for the ODEs, given a graph, an Interaction Mode and a Taxation Mode.\n\nArguments\n\ng::SimpleGraph{<:Integer}: Undirected graph.\ninteraction_mode::String: Interaction Mode. Can be \"A\" or \"B\".\ntaxation_mode::String: Taxation Mode. Can be \"A\" or \"B\".\n\nReturns\n\nTuple{Vector{Float64},Vector{Float64}}: κ matrix and β vector.\n\nExamples\n\ng = complete_graph(4)\nYardSale.get_kappa_beta(g,\"A\",\"A\")\n\n\n\n\n\n","category":"method"},{"location":"references/utils/#YardSale.EYSM_base_redistribution-Tuple{Real, Real, Real}","page":"Utils","title":"YardSale.EYSM_base_redistribution","text":"EYSM_base_redistribution(wi, W_N, chif_N)\n\nCalculates the redistribution term in the EYSM model for an agent i with wealth wi.\n\nArguments\n\nwi::Real: Wealth of agent i.\nW_N::Real: Total wealth per agent.\nchif_N::Real: Taxation and redistribution rate.\n\nDetails\n\nIn the EYSM model, the redistribution term of the wealth update of agent i is given by\n\nfracchi fN(fracWN - w_i)\n\nwhere f is the fraction of the minimum wealth exchanged between agents, and f is playing the role of the Δt term in the Fokker-Planck approach, as the temporal unit of time of the Monte Carlo simulation. chi represents the taxation and redistribution rate and N is the number of agents.\n\nReturns\n\nredist::Real: Redistribution term for agent i.\n\n\n\n\n\n","category":"method"},{"location":"references/utils/#YardSale.mc_set_initial_conditions","page":"Utils","title":"YardSale.mc_set_initial_conditions","text":"mc_set_initial_conditions(N, W_N, initial_conditions,w=nothing)\n\nSet the initial conditions for the Monte Carlo simulation.\n\nArguments\n\nN::Integer: Number of agents.\nW_N::Real: Total wealth per agent.\ninitial_conditions::String: Initial condition. Options are \"uniform\", \"random\", \"noisy\"\nand \"custom\".\nw::Union{Nothing, Vector{<:Real}}=nothing: Initial wealth distribution. Only used if\ninitial_conditions=\"custom\". Default is nothing.\n\nReturns\n\nw::Vector{Real}: Initial wealth distribution.\n\n\n\n\n\n","category":"function"},{"location":"references/utils/#YardSale.Δw-NTuple{4, Real}","page":"Utils","title":"YardSale.Δw","text":"Δw(wi,wj,ri,rj)\n\nCalculate the amount of wealth exchanged between agents i and j in the YS model with risk aversion.\n\nArguments\n\nwi::Real: Wealth of agent i.\nwj::Real: Wealth of agent j.\nri::Real: Risk propension of agent i.\nrj::Real: Risk propension of agent j.\n\nReturns\n\nΔw::Real: Amount of wealth exchanged between agents i and j.\n\n\n\n\n\n","category":"method"},{"location":"references/utils/#YardSale.ηij-Tuple{Real, Real, Real}","page":"Utils","title":"YardSale.ηij","text":"ηij(wi, wj, zeta_W)\n\nCalculate the stochastic variable ηij in the EYSM model.\n\nArguments\n\nwi::Real: Wealth of agent i.\nwj::Real: Wealth of agent j.\nzeta_W::Real: Normalized bias towards the richest agent.\n\nDetails\n\nThe expected value of ηij is given by\n\nlangleeta_ijrangle = zeta fracw_i - w_jW\n\nThis variable is used to determine the direction of the wealth exchange between agents i and j, and can take values ±1.\n\nReturns\n\nηij::Real Stochastic variable ηij.\n\n\n\n\n\n","category":"method"},{"location":"references/utils/#YardSale.ode_set_initial_conditions","page":"Utils","title":"YardSale.ode_set_initial_conditions","text":"ode_set_initial_conditions(N, initial_conditions,x0=nothing)\n\nSet the initial conditions for the ODE simulation.\n\nArguments\n\nN::Integer: Number of agents.\ninitial_conditions::String: Initial condition. Options are \"uniform\", \"random\", \"noisy\"\nand \"custom\".\nx0::Union{Nothing, Vector{<:Real}}=nothing: Initial wealth distribution. Only used if\ninitial_conditions=\"custom\". Default is nothing.\n\nReturns\n\nx::Vector{Real}: Initial wealth distribution.\n\n\n\n\n\n","category":"function"},{"location":"references/utils/#YardSale.get_giant_component-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"Utils","title":"YardSale.get_giant_component","text":"get_giant_component(g::SimpleGraph)\n\nReturns the giant component of a graph.\n\n\n\n\n\n","category":"method"},{"location":"references/utils/#YardSale.get_graph_data-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"Utils","title":"YardSale.get_graph_data","text":"get_graph_data(g::SimpleGraph)\n\nReturns the number of nodes, the number of links, and the edgelist of the giant component of a graph.\n\nDetails\n\nIf the graph has more than one connected component, a warning is issued, and the giant component is used for the simulation.\n\n\n\n\n\n","category":"method"},{"location":"references/utils/#YardSale.x1_meanField-Tuple{Real, Int64}","page":"Utils","title":"YardSale.x1_meanField","text":"x1_meanField(T::Real,N::Int)\n\nMean field prediction for the wealth of the richest agent in the system as a function of the temperature T. This is the finite size case, i.e. N is finite.\n\nArguments\n\n`T::Real`: temperature of the system\n`N::Int`: number of agents in the system\n\nReturns\n\n`x1::Real`: mean field prediction for the wealth of the richest agent\n\n\n\n\n\n","category":"method"},{"location":"references/utils/#YardSale.x1_meanField-Tuple{Real}","page":"Utils","title":"YardSale.x1_meanField","text":"x1_meanField(T::Real)\n\nMean field prediction for the wealth of the richest agent in the system as a function of the temperature T. This is the thermodinamic limit case, i.e. N -> ∞.\n\nArguments\n\n`T::Real`: temperature of the system\n\nReturns\n\n`x1::Real`: mean field prediction for the wealth of the richest agent\n\n\n\n\n\n","category":"method"},{"location":"references/utils/#Data-analysis","page":"Utils","title":"Data analysis","text":"","category":"section"},{"location":"references/utils/","page":"Utils","title":"Utils","text":"Miscellaneous functions for data analysis. Common tools for the analysis of Monte Carlo and ODE simulations.","category":"page"},{"location":"references/utils/","page":"Utils","title":"Utils","text":"Modules = [YardSale]\nPages = [\"data_analysis/mc_analysis_functions.jl\",\"data_analysis/ode_analysis_functions.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"references/utils/#YardSale.get_avg_x1-Tuple{AbstractArray, Integer}","page":"Utils","title":"YardSale.get_avg_x1","text":"get_avg_x1(x::AbstractMatrix, dims::Vararg{Integer}=2)\n\nGet the temporal average of the richest node and the variance.\n\nArguments\n\nx1::AbstractMatrix: Matrix of the MC simulation.\ndims::Vararg{Integer}: Dimension(s) to get the richest node.\nIt can be an integer or a tuple of integers.\n\nReturns\n\navg_x1::Tuple{Float64, Float64}: Tuple with the average and variance of the richest node.\n\n\n\n\n\n","category":"method"},{"location":"references/utils/#YardSale.get_x1-Tuple{AbstractArray, Vararg{Integer}}","page":"Utils","title":"YardSale.get_x1","text":"get_x1(x::AbstractMatrix, dims::Union{Integer, Tuple{Integer, Integer}}=2)\nGet the richest node at each time step.\n\nArguments\n\nx::AbstractMatrix: Matrix of the MC solution.\ndims::Union{Integer, Tuple{Integer, Integer}}: Dimension(s) to get the richest node.\nIt can be an integer or a tuple of integers.\n\nReturns\n\nx1::AbstractArray: Richest node at each time step.\n\n\n\n\n\n","category":"method"},{"location":"references/utils/#YardSale.get_lambda-Tuple{Graphs.SimpleGraphs.SimpleGraph, String, String, Real, Vector{<:Real}}","page":"Utils","title":"YardSale.get_lambda","text":"get_lambda(g::SimpleGraph{<:Integer}, interaction_mode::String,\ntaxation_mode::String, T::Real, x_ss::Vector{<:Real})\n\nGet the Lambda matrix for the ODE system.\n\nArguments\n\ng::SimpleGraph{<:Integer}: Graph object.\ninteraction_mode::String: Interaction mode.\ntaxation_mode::String: Taxation mode.\nT::Real: Taxation rate.\nx_ss::Vector{<:Real}: Steady state vector.\n\nReturns\n\nLambda::Matrix{Float64}: Lambda matrix.\n\nDetails\n\nComing soon.\n\n\n\n\n\n","category":"method"},{"location":"references/utils/#YardSale.get_max_eigenvalue-Tuple{AbstractMatrix}","page":"Utils","title":"YardSale.get_max_eigenvalue","text":"get_max_eigenvalue(Lambda::Array{<:Real})\n\nGet the maximum real part of the eigenvalues of the a real matrix. We use this function to determine the stability of the ODE system.\n\nArguments\n\nLambda::Array{<:Real}: Matrix.\n\nReturns\n\nmax_eigenvalue::Real: Maximum real part of the eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"references/utils/#YardSale.rescale_t-Tuple{AbstractVector, Integer}","page":"Utils","title":"YardSale.rescale_t","text":"rescale_t(t::AbstractVector,N::Integer)\n\nRescale the ODE time vector to MC steps.\n\nArguments\n\nt::AbstractVector: Time vector of the ODE solution.\nN::Integer: Number of nodes in the network.\n\nReturns\n\nrescaled_t::AbstractVector: Rescaled time vector.\n\n\n\n\n\n","category":"method"},{"location":"references/ode/#ODE-Solvers","page":"ODE systems","title":"ODE Solvers","text":"","category":"section"},{"location":"references/ode/","page":"ODE systems","title":"ODE systems","text":"Modules = [YardSale]\nPages = [\"ode/ode_solvers.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"references/ode/#YardSale.dxdt_net!-NTuple{4, Any}","page":"ODE systems","title":"YardSale.dxdt_net!","text":"dxdt_net!(dxdt, x, p, t)\n\nIn-place function to calculate the derivatives of the network model.\n\nArguments\n\ndxdt::Vector{<:Real}: Vector of derivatives.\nx::Vector{<:Real}: Vector of wealths.\np::Tuple{<:Integer, <:Integer, Vector{Vector{<:Integer}},\nVector{<:Integer}, Vector{<:Array}, ::Real, ::Real}: Parameters.\nt::Float64: Time.\n\nDetails\n\nThe network model is given by the following set of ODEs:\n\ndotx_i = fracTN (- beta_i x_i + sum_j^N beta_j x_j) + sum_j^N kappa_ij\n(x_i - x_j) min(x_i x_j)\n\nwhere x_i is the wealth of node i, T is temperature, N is the number of nodes, beta_i is the redistribution parameter of node i, kappa_ij is the exchange parameter between nodes i and j.\n\n\n\n\n\n","category":"method"},{"location":"references/ode/#YardSale.solve_ode_net-Tuple{Graphs.SimpleGraphs.SimpleGraph, Tuple{Real, Real}, String, String, Real, Integer}","page":"ODE systems","title":"YardSale.solve_ode_net","text":"solve_ode_net(g, tspan, integrator, interaction_mode, taxation_mode, T, seed; kwargs...)\n\nSolves the ODE for the network model.\n\nArguments\n\ng::SimpleGraph{<:Integer}: Graph.\ntspan::Tuple{Float64, Float64}: Tuple with initial and final time.\ninteraction_mode::String: Interaction mode.\ntaxation_mode::String: Taxation mode.\nT::Real: Temperature.\nseed::Integer: Random seed.\n\nOptional arguments\n\n`integrator::SciMLAlgorithm`: An instante of the integrator to use. Default is Tsit5().\ninitial_conditions::String=nothing: Initial condition. Options are\n\"uniform\", \"random\", \"noisy\" and \"custom\". Default is \"uniform\". If \"custom\" is\nchosen, the x0 argument must be provided.\nx0::Union{Nothing, Vector{<:Real}}=nothing: Initial wealth distribution.\n`kwargs...`: Additional arguments for the solver.\n\nDetails\n\nThis function solves the ODE for the network model. It calculates the kappa and beta parameters, sets the initial conditions, and solves the ODE. It returns the solution in the standard DifferentialEquations.jl format. A brief description of the ODE approximation model can be found in the dxdt_net! function. The function uses the DifferentialEquations.jl package to solve the ODE. All the parameters for the solver can be passed as keyword arguments.\n\nThe initial conditions can be set to \"noisy\", \"random\", \"uniform\", or a custom vector.\n\n\"noisy\": Initial conditions are set to a random value around 1/N.\n\nx = (1N) * (1 + epsilon) where ϵ is white noise with μ=0 and σ=0.01.\n\n\"random\": Initial conditions are set to a random value, normalized to sum to 1.\n\"uniform\": Initial conditions are set to 1/N.\n\"custom\": Initial conditions are set to a custom vector. The vector must sum to 1.\n\nAlso, x_i must be positive for all i.\n\nReturns\n\nsol::ODESolution: Solution of the ODE.\n\nExamples\n\nusing DifferentialEquations, Graphs, YardSale\n# Create a graph\ng = erdos_renyi(100, 0.1, seed=42)\ninteraction_mode, taxation_mode = \"A\",\"A\"\nT = 1.0\nseed = 42\ntspan = (0.0, 10.0)\nsol1 = solve_ode_net(g, tspan, interaction_mode, taxation_mode, T, seed)\nsol2 = solve_ode_net(g, tspan, interaction_mode, taxation_mode, T, seed; integrator=RK4())\nsol3 = solve_ode_net(g, tspan, interaction_mode, taxation_mode, T, seed;\nintegrator=RK4(), reltol=1e-6, abstol=1e-6)\n\n\n\n\n\n","category":"method"},{"location":"references/ode/#YardSale.solve_ode_net_SS-Tuple{Graphs.SimpleGraphs.SimpleGraph, String, String, Real, Integer}","page":"ODE systems","title":"YardSale.solve_ode_net_SS","text":"solve_ode_net_SS(g, interaction_mode, taxation_mode, T, seed;\ninitial_conditions=\"noisy\",integrator=Tsit5(), kwargs...)\n\nSolves the ODE for the network model using a steady state solver.\n\nArguments\n\ng::SimpleGraph{<:Integer}: Graph.\ninteraction_mode::String: Interaction mode.\ntaxation_mode::String: Taxation mode.\nT::Real: Temperature.\nseed::Integer: Random seed.\n\nOptional arguments\n\n`initial_conditions::Union{String, Vector{<:Real}}`=\"noisy\": Initial conditions\nfor the ODE. Default is \"noisy\", which sets the initial conditions to a random value\naround 1/N. Other options are \"random\" and \"uniform\". If a vector is passed, it will be\nused as the initial conditions.\n`x0::Union{Nothing, Vector{<:Real}}`=nothing: Initial wealth distribution.\n`integrator::SciMLAlgorithm`: An instance of the integrator to use. Default is Tsit5().\n`kwargs...`: Additional arguments for the solver.\n\nDetails\n\nThis function solves the ODE for the network model using a steady state solver. It is similar to solve_ode_net, but it uses the DynamicSS solver to find the steady state. Instead of an ODE problem, it uses a SteadyStateProblem to solve the ODE. Reference: https://docs.sciml.ai/DiffEqDocs/stable/types/steadystatetypes/\n\nAs in solve_ode_net, the initial conditions can be set to \"noisy\", \"random\", \"uniform\", or a custom vector.\n\nReturns\n\nsol::ODESolution: Solution of the ODE.\n\nExamples\n\nusing DifferentialEquations, Graphs, YardSale\n# Create a graph\ng = erdos_renyi(100, 0.1, seed=42)\ninteraction_mode, taxation_mode = \"A\",\"A\"\nT = 1.0\nseed = 42\nsol1 = solve_ode_net_SS(g, interaction_mode, taxation_mode, T, seed)\nsol2 = solve_ode_net_SS(g, interaction_mode, taxation_mode, T, seed; integrator=RK4())\nsol3 = solve_ode_net_SS(g, interaction_mode, taxation_mode, T, seed;\n                            integrator=RK4(),reltol=1e-6, abstol=1e-6\n                            )\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#Monte-Carlo-Simulations","page":"Monte Carlo","title":"Monte Carlo Simulations","text":"","category":"section"},{"location":"references/mc/","page":"Monte Carlo","title":"Monte Carlo","text":"Modules = [YardSale]\nPages = [\"mc/mc_simulator.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"references/mc/#YardSale.EYSM_base_callbacks-Tuple{Integer, Real, Real, Real, Real, Integer, Integer}","page":"Monte Carlo","title":"YardSale.EYSM_base_callbacks","text":"EYSM_base_callbacks(N, W_N, chi, zeta, f, steps, seed; w=nothing,\ninitial_conditions=\"uniform\",save_every=nothing, callbacks=nothing,\ncallbacks_only=false)\n\nRuns a Monte Carlo simulation of the Extended Yard-Sale Model on a fully connected network and returns the whole time series of the wealth distribution and the results of the callbacks.\n\nArguments\n\nN::Integer: Number of agents.\nW_N::Real: Mean wealth of the agents. It is the total wealth divided by the number\nof agents.\nchi::Real: Taxation rate.\nzeta::Real: Wealth-Attained-Advantage parameter.\nf::Real: Fraction of the wealth that is redistributed.\nsteps::Integer: Number of steps of the simulation, measured in Monte Carlo steps.\nseed::Integer: Seed for the random number generator.\n\nOptional arguments\n\nw0::Union{Nothing, Vector{<:Real}}=nothing: Initial wealth distribution.\nOnly used if initial_conditions=\"custom\". Default is nothing.\ninitial_conditions::String=nothing: Initial condition. Options are\n\"uniform\", \"random\", \"noisy\" and \"custom\". Default is \"uniform\". If \"custom\" is\nchosen, the w argument must be provided.\nsave_every::Union{Nothing, Integer}=nothing: Save the wealth distribution every\nsave_every steps. Default is nothing, which means saving every N steps.\ncallbacks::Union{Nothing, Dict{Symbol, Function}}=nothing: Dictionary of callbacks.\nThe keys are the names of the callbacks, and the values are the functions that will be\ncalled at each checkpoint. The functions must receive the wealth distribution\nas an argument.\n\nReturns\n\nw_t::Union{Nothing, Matrix{Real}}: Time series of the wealth distribution. Each row is a checkpoint.\ncallback_results::Union{Nothing, Dict{Symbol, AbstractVector}}: Results of the callbacks.\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#YardSale.EYSM_base_full-Tuple{Integer, Real, Real, Real, Real, Integer, Integer}","page":"Monte Carlo","title":"YardSale.EYSM_base_full","text":"EYSM_base_full(N, W_N, chi, zeta, f, steps,seed; w=nothing,initial_conditions=\"uniform\",\nsave_every=nothing)\n\nRuns a Monte Carlo simulation of the Extended Yard-Sale Model and returns the whole time series of the wealth distribution.\n\nArguments\n\nN::Integer: Number of agents.\nW_N::Real: Mean wealth of the agents. It is the total wealth divided by the number\nof agents.\nchi::Real: Taxation rate.\nzeta::Real: Wealth-Attained-Advantage parameter.\nf::Real: Fraction of the wealth that is redistributed.\nsteps::Integer: Number of steps of the simulation, measured in Monte Carlo steps.\nseed::Integer: Seed for the random number generator.\n\nOptional arguments\n\nw0::Union{Nothing, Vector{<:Real}}=nothing: Initial wealth distribution.\nOnly used if initial_conditions=\"custom\". Default is nothing.\ninitial_conditions::String=nothing: Initial condition. Options are\n\"uniform\", \"random\", \"noisy\" and \"custom\". Default is \"uniform\". If \"custom\" is\nchosen, the w0 argument must be provided.\nsave_every::Union{Nothing, Integer}=nothing: Save the wealth distribution every\nsave_every steps. Default is nothing, which means saving every N steps.\n\nReturns\n\nDetails\n\nThis function tries to reproduce as closely as possible the results of the original EYSM proposed by Boghosian et al. in 2017. The model has two parameters, and it is defined for a fully connected network of N agentes, each one with a wealth w_i, such that the total wealth sum_i w_i = W is conserved.\n\nThe interaction rule is defined as follows:\n\nRandomly select two agents i and j.\nThe amount of wealth exchanged is given by a fraction of the minimum between\n\nthe wealths of the two agents.\n\nDelta w = fmin(w_i w_j)eta_ij\n\nwhere eta_ij is a stochastic variable with values -1 or 1. The expected value of eta_ij is biased towards the richest agent, and it is given by\n\nlangleeta_ijrangle = zeta fracw_i - w_jW\n\nThe wealth of the agents is updated as follows:\n\nw_i to w_i - Delta w + chi (fracWN - w_i)\nw_j to w_j + Delta w + chi (fracWN - w_j)\n\nwhere chi represents the taxation and redistribution rate\n\nIn the original paper the authors work analitically using a Fokker-Planck approach In this\nimplementation we use a Monte Carlo simulation to obtain similar results\n\n Examples\n\njulia wt1 = EYSMbasefull(1000, 1, 0.1, 0.1, 1, 1000, 42) wt2 = EYSMbasefull(64, 1.0f0, 0.1f0, 0.1f0, 1, 1000, 42, initialconditions=\"random\") wt3 = EYSMbasefull(32, 1, 0.1, 0.1, 1, 1000, 42, initialconditions=\"custom\", w=rand(1000)) ```\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#YardSale.EYSM_net_callbacks-Tuple{Graphs.SimpleGraphs.SimpleGraph, Real, String, String, Real, Real, Real, Integer, Integer}","page":"Monte Carlo","title":"YardSale.EYSM_net_callbacks","text":"EYSM_net_callbacks(g::SimpleGraph,W_N, interaction_mode, taxation_mode, chi, zeta, f,\nsteps, seed; w=nothing,initial_conditions=\"uniform\",save_every=nothing,\ncallbacks=nothing,callbacks_only=false)\n\nRuns a Monte Carlo simulation of the Extender Yard-Sale model on an arbitrary network and returns the whole time series of the wealth distribution and the results of the callbacks.\n\nArguments\n\ng::SimpleGraph{<:Integer}: Graph representing the network of agents.\nW_N::Real: Mean wealth of the agents. It is the total wealth divided by the number\nof agents.\ninteraction_mode::String: Interaction mode. Options are \"A\" and \"B\".\ntaxation_mode::String: Taxation mode. Options are \"A\" and \"B\".\nchi::Real: Taxation rate.\nzeta::Real: Wealth-Attained-Advantage parameter.\nf::Real: Fraction of the wealth that is redistributed.\nsteps::Integer: Number of steps of the simulation, measured in Monte Carlo steps.\nseed::Integer: Seed for the random number generator.\n\nOptional arguments\n\nw0::Union{Nothing, Vector{<:Real}}=nothing: Initial wealth distribution.\nOnly used if initial_conditions=\"custom\". Default is nothing.\ninitial_conditions::String=nothing: Initial condition. Options are\n\"uniform\", \"random\", \"noisy\" and \"custom\". Default is \"uniform\". If \"custom\" is\nchosen, the w argument must be provided.\nsave_every::Union{Nothing, Integer}=nothing: Save the wealth distribution every\nsave_every steps. Default is nothing, which means saving every N steps.\ncallbacks::Union{Nothing, Dict{Symbol, Function}}=nothing: Dictionary of callbacks.\nThe keys are the names of the callbacks, and the values are the functions that will be\ncalled at each checkpoint. The functions must receive the wealth distribution as an\nargument.\n\nReturns\n\nw_t::Union{Nothing, Matrix{Real}}: Time series of the wealth distribution.\nEach row is a checkpoint.\ncallback_results::Union{Nothing, Dict{Symbol, AbstractVector}}: Results of the callbacks.\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#YardSale.EYSM_net_full-Tuple{Graphs.SimpleGraphs.SimpleGraph, Real, String, String, Real, Real, Real, Integer, Integer}","page":"Monte Carlo","title":"YardSale.EYSM_net_full","text":"EYSM_net_full(g::SimpleGraph,W_N, interaction_mode, taxation_mode, chi, zeta, f, steps,\nseed; w=nothing,initial_conditions=\"uniform\",save_every=nothing)\n\nRuns a Monte Carlo simulation of the Extender Yard-Sale model on an arbitrary network and returns the whole time series of the wealth distribution.\n\nArguments\n\ng::SimpleGraph{<:Integer}: Graph representing the network of agents.\nW_N::Real: Mean wealth of the agents. It is the total wealth divided by the number\nof agents.\ninteraction_mode::String: Interaction mode. Options are \"A\" and \"B\".\ntaxation_mode::String: Taxation mode. Options are \"A\" and \"B\".\nchi::Real: Taxation rate.\nzeta::Real: Wealth-Attained-Advantage parameter.\nf::Real: Fraction of the wealth that is redistributed.\nsteps::Integer: Number of steps of the simulation, measured in Monte Carlo steps.\nseed::Integer: Seed for the random number generator.\n\nOptional arguments\n\nw0::Union{Nothing, Vector{<:Real}}=nothing: Initial wealth distribution.\nOnly used if initial_conditions=\"custom\". Default is nothing.\ninitial_conditions::String=nothing: Initial condition. Options are\n\"uniform\", \"random\", \"noisy\" and \"custom\". Default is \"uniform\". If \"custom\" is\nchosen, the w argument must be provided.\nsave_every::Union{Nothing, Integer}=nothing: Save the wealth distribution every\nsave_every steps. Default is nothing, which means saving every N steps.\n\nDetails\n\nThis function is the generalization of the EYSMbasefull function to arbitrary networks. In the extension, an ambiguity arises in the definition of the interaction rule and the taxation rule. That is why we have to define previously the way in which agents will be selected to exchange wealth and the way in which the taxation will be applied. For each of these two steps, we have two options, which are defined by the interactionmode and taxationmode. The interaction_mode defines the way in which agents will be selected to exchange wealth. The options are:\n\n\"A\": Randomly select a link.\n\"B\": Randomly select a node and one of its neighbors.\n\nThe taxation_mode defines the way in which the taxation will be applied. The options are:\n\n\"A\": Tax exchanging agents.\n\"B\": Tax two random agents.\n\nThe equation governing the wealth exchange is a generalization of the one used in the EYSMbasefull function:\n\nDelta w_i(t) = chiDelta t(-b_i(t) w_i(t) + frac1Nsum_j b_j(t)w_j(t))\n+ sum_j c_ij(t)sqrtgammaDelta t eta_ij(t)min(w_i(t) w_j(t))\n\nwhere now b_i(t) represents an event of taxation over agent i and c_ij(t) represents an event of wealth exchange between agents i and j. To see the ODE system that describes an equivalent dynamics, see the documentation of the solve_ode_net function.\n\nReturns\n\nw_t::Matrix{Real}: Time series of the wealth distribution. Each row is a checkpoint.\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#Callbacks","page":"Monte Carlo","title":"Callbacks","text":"","category":"section"},{"location":"references/mc/","page":"Monte Carlo","title":"Monte Carlo","text":"In the context of Monte Carlo simulations, a callback is a function that is called at the end of each iteration of the simulation. This can be used to monitor the progress of the simulation with any desired metrics. The callbacks functions take the state of the simulation as an argument, i.e. f(w) where w is the wealth distribution at the current iteration. It is easy to define custom callbacks by defining a function that takes the wealth distribution as an argument and returns something (a number, a vector, etc.). The function can then be passed to the mc_simulator function as a callback.","category":"page"},{"location":"references/mc/","page":"Monte Carlo","title":"Monte Carlo","text":"Some predefined callbacks are available in the YardSale module, which are commonly used in the study of wealth distributions. These are:","category":"page"},{"location":"references/mc/","page":"Monte Carlo","title":"Monte Carlo","text":"Modules = [YardSale]\nPages = [\"mc/callbacks.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"references/mc/#YardSale.get_R-Tuple{Vector{<:Real}}","page":"Monte Carlo","title":"YardSale.get_R","text":"get_R(w::Vector{<:Real})\n\nCalculate the number of agents with wealth above the poverty line.\n\nArguments\n\nw::Vector{<:Real}: Wealth distribution.\n\nReturns\n\nR::Int: Number of agents with wealth above the poverty line (mean wealth).\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#YardSale.get_gini-Tuple{Vector{<:Real}}","page":"Monte Carlo","title":"YardSale.get_gini","text":"get_gini(w::Vector{<:Real})\n\nCalculate the Gini coefficient of the wealth distribution.\n\nArguments\n\nw::Vector{<:Real}: Wealth distribution.\n\nDetails\n\nThe Gini coefficient is a measure of statistical dispersion intended to represent the income or wealth distribution of a nation's residents, and is the most commonly used measure of inequality. It ranges from 0 (perfect equality) to 1 (perfect inequality). The formula for the Gini coefficient is:\n\ng = frac12NW sum_ij^N w_i - w_j\n\nwhere N is the number of agents, W is the total wealth, and w_i is the wealth of agent i.\n\nReturns\n\ngini::Real: Gini coefficient.\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#YardSale.get_lorenz-Tuple{Vector{<:Real}}","page":"Monte Carlo","title":"YardSale.get_lorenz","text":"get_lorenz(w::Vector{<:Real})\n\nCalculate the Lorenz curve of the wealth distribution.\n\nArguments\n\nw::Vector{<:Real}: Wealth distribution.\n\nDetails\n\nThe Lorenz curve is a graphical representation of the distribution of income or wealth. It plots the cumulative percentage of total income received against the cumulative percentage of recipients, starting with the poorest individual or household. It is used to represent income or wealth inequality. The Lorenz curve is a concave curve that lies below the diagonal line of perfect equality, which represents a situation where everyone has the same income or wealth.\n\nReturns\n\nlorenz::Vector{<:Real}: Lorenz curve.\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#YardSale.get_r-Tuple{Vector{<:Real}}","page":"Monte Carlo","title":"YardSale.get_r","text":"get_r(w::Vector{<:Real})\n\nCalculate the fraction of agents with wealth above the poverty line.\n\nArguments\n\nw::Vector{<:Real}: Wealth distribution.\n\nReturns\n\nr::Real: Fraction of agents with wealth above the poverty line.\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#YardSale.get_u-Tuple{Vector{<:Real}}","page":"Monte Carlo","title":"YardSale.get_u","text":"get_u(w::Vector{<:Real})\n\nCalculate the relative mean wealth of agents with wealth above the poverty line (mean wealth)\n\nArguments\n\nw::Vector{<:Real}: Wealth distribution.\n\nReturns\n\nu::Real: Mean wealth of agents with wealth above the poverty line.\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#YardSale.get_x1-Tuple{Vector{<:Real}}","page":"Monte Carlo","title":"YardSale.get_x1","text":"get_x1(w::Vector{<:Real})\n\nCalculate the wealth fraction of the richest agent in the system.\n\nArguments\n\nw::Vector{<:Real}: Wealth distribution.\n\nReturns\n\nx1::Real: Wealth fraction of the richest agent.\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#YardSale.get_xi-Tuple{Vector{<:Real}, Int64}","page":"Monte Carlo","title":"YardSale.get_xi","text":"get_xi(w::Vector{<:Real}, i::Int)\n\nCalculate the wealth fraction of the i-th richest agent in the system.\n\nArguments\n\nw::Vector{<:Real}: Wealth distribution.\ni::Int: Rank of the agent.\n\nReturns\n\nxi::Real: Wealth fraction of the i-th richest agent.\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#Risk-aversion-models","page":"Monte Carlo","title":"Risk aversion models","text":"","category":"section"},{"location":"references/mc/","page":"Monte Carlo","title":"Monte Carlo","text":"Modules = [YardSale]\nPages = [\"mc/risk_aversion_models.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"references/mc/#YardSale.YS_base_risk-Tuple{Integer, Real, Integer, AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Monte Carlo","title":"YardSale.YS_base_risk","text":"YSbaserisk(N, WN, T, initialconditions, beta; seed = nothing)\n\nRun the Yard-Sale model with risk aversion for N agents with wealth exchange in a fully connected network.\n\nArguments\n\nN::Integer: Number of agents\nW_N::Real: Wealth/N quotient\nsteps::Integer: Number of MC steps\ninitial_conditions::AbstractVector{<:Real}: Initial conditions\nbeta::AbstractVector{<:Real}: Beta values (risk aversion)\nseed::Union{Nothing, Int64}: Seed for reproducibility (optional)\n\nDetails\n\nThe model is defined by the following wealth exchange rule: `math Delta w_ij = min((1-beta_i) w_i (1 - beta_j) w_j)  where\\beta_i`` is the risk aversion of agent i.\n\nOutput\n\nw_t::Matrix{Float32}: T x N matrix with the wealth of the agents at each time step\n\n\n\n\n\n","category":"method"},{"location":"references/mc/#YardSale.YS_net_risk-Tuple{Graphs.SimpleGraphs.SimpleGraph, Real, Integer, AbstractVector{<:Real}, String, AbstractVector{<:Real}}","page":"Monte Carlo","title":"YardSale.YS_net_risk","text":"YS_net_risk(g, W_N, T, initial_conditions, beta; seed = nothing, exchange_mode)\n\nRun the Yard-Sale model with risk aversion for N agents with wealth exchange in a complex network.\n\nArguments\n\ng::SimpleGraph{<:Integer}: Graph\nW_N::Real: Wealth/N quotient\nsteps::Integer: Number of MC steps\ninitial_conditions::AbstractVector{<:Real}: Initial conditions\nbeta::AbstractVector{<:Real}: Beta values (risk aversion)\nseed::Union{Nothing, Int64}: Seed for reproducibility (optional)\nexchange_mode::String: \"link\" or \"node\"\n\nDetails\n\nThe model is defined by the following wealth exchange rule: `math Delta w_ij = min((1-beta_i) w_i (1 - beta_j) w_j)  where\\beta_i`` is the risk aversion of agent i.\n\nAt each time step, two agents are chosen at random. The wealth exchange is calculated according to the rule above, and the wealth of the agents is updated.\n\nTwo exchange modes are available:\n\n\"link\": One link chosen at random, and the wealth exchange is calculated between the two\n\nagents.\n\n\"node\": A node is chosen at random, and one of its neighbors is chosen at random.\n\nOutput\n\nw_t::Matrix{Float32}: T x N matrix with the wealth of the agents at each time step\n\n\n\n\n\n","category":"method"},{"location":"tutorials/using_callbacks/using_callbacks/#Import-necessary-packages","page":"Using callbacks","title":"Import necessary packages","text":"","category":"section"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"using Pkg; Pkg.activate(\".\")\nusing Plots, LaTeXStrings\nusing Graphs\nusing YardSale","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/#Overview-of-the-notebook","page":"Using callbacks","title":"Overview of the notebook","text":"","category":"section"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"We'll explore briefly the functionalities of the MC simulations; particularly, we want to show how to use different callbacks functions to monitor the simulation.","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"We can start by defining the basic parameters of the simulation, such as the number of agentes, mean wealth, chi and zeta parameters, and the number of steps.","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"N = 128\nW_N = 1.0f0\nchi = 0.75f0\nzeta = 1.0f0\nf = 0.01f0\nsteps = 20000 * N\nseed = 42\n;","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/#Simulations-using-callbacks","page":"Using callbacks","title":"Simulations using callbacks","text":"","category":"section"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"For the callbacks, the function EYSM_base_callbacks is defined to incorporate callbacks. In general, callbacks must be functions that receive the wealth distribution at time t and return some metric of interest (which can be a number, a vector, etc.). The functions must be passed as a dictionary, where the key is a symbol that identifies the callback and the value is the function itself. In this example, we'll use the following callbacks:","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"gini: computes the Gini coefficient of the wealth distribution.\nx1: computes the relative wealth of the richest agent.\nlorenz: computes the Lorenz curve of the wealth distribution.","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"All this functions are defined inside the package. Of course, you can define your own functions and pass them to the simulation.","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"After defining the callbacks, we can choose between get the whole history of the wealth distribution, or just the metrics of interes. This is done by setting the callbacks_only parameter to True or False.","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"callbacks = Dict(:gini => YardSale.get_gini, :x1 => YardSale.get_x1,:lorenz => YardSale.get_lorenz)\ncallbacks_only = true","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"true","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"# Run the simulation\nresults = EYSM_base_callbacks(N, W_N, chi, zeta, f, steps, seed; callbacks=callbacks, callbacks_only=callbacks_only)","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"Dict{Symbol, AbstractVector} with 3 entries:\n  :lorenz => Vector{Float32}[[0.0078125, 0.015625, 0.0234375, 0.03125, 0.039062…\n  :gini   => Float32[0.0, 0.0852903, 0.111675, 0.136057, 0.157808, 0.177768, 0.…\n  :x1     => Float32[0.0078125, 0.0107773, 0.0111418, 0.0135276, 0.0133853, 0.0…","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"For the end, we can plot the results from the callbacks.","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"p1 = plot(results[:gini], label=\"Gini coefficient\",minorticks=true,palette=:julia,\n        xlabel=\"Time\", ylabel=L\"g,x_1\")\nplot!(p1, results[:x1], label=L\"x_1\",minorticks=true,palette=:julia)\n\np2 = plot(\n    (1:N) ./ N, results[:lorenz][1],color=3, ls=:dash, label=\"Initial\",\n    minorticks=true,palette=:julia, legend_title=\"Lorenz curve\",\n    xlabel=\"Fraction of population\", ylabel=\"Fraction of wealth\",lw=2\n\n    )\nplot!(p2, (1:N) ./ N, results[:lorenz][end],color=3, label=\"Final\", lw=2)\n\np = plot(p1, p2, layout=(2,1), size=(800, 600))\ndisplay(p)","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"(Image: EYSM Base Time Evolution)","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/#Callbacks-in-MC-simulations-over-networks","page":"Using callbacks","title":"Callbacks in MC simulations over networks","text":"","category":"section"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"We can also run the MC simulations over networks. In this case, we can use the same callbacks as before, but we can also use the EYSM_net_callbacks function. Let's test this function over a Erdös-Rényi network.","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"For this demonstration, we'll use a fragmented network, to show that the function can handle this kind of network, leaving the isolated nodes out of the simulation, and only considering the giant component.","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"N = 128\nk_mean = 8\n# Seed for the disconnected random graph (check disconnection with is_connected(g))\nseed_er = 10\ng = erdos_renyi(N, k_mean/(N-1), seed = seed_er)\n\nprintln(\"Is connected: \", is_connected(g))","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"Is connected: false","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"# Simulation parameters\nW_N = 1.0f0\ninteraction_mode = \"A\"\ntaxation_mode = \"A\"\nchi = 0.10f0\nzeta = 1.0f0\nf = 0.01f0\nsteps = 20000 * N\nseed = 42\n\n\ncallbacks = Dict(:gini => YardSale.get_gini, :x1 => YardSale.get_x1,:lorenz => YardSale.get_lorenz)\ncallbacks_only = false\n;","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"# Run the simulation\nw_t, callback_results = EYSM_net_callbacks(\n    g,W_N,interaction_mode,taxation_mode,chi,zeta,f,steps,seed;\n    callbacks=callbacks,callbacks_only=callbacks_only\n)\n;","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"Warning: The graph has a giant component of 127 nodes.\nThe original graph has 128 nodes.\nWe will use the giant component for the simulation.\nYardSale C:\\Users\\nicol\\.julia\\packages\\YardSale\\DqbVW\\src\\utils\\graph_functions.jl:26","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"Now we plot the results from the callbacks for the network simulation.","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"p1 = plot(callback_results[:gini], label=\"Gini coefficient\",minorticks=true,palette=:julia,\n        xlabel=\"Time\", ylabel=L\"g,x_1\")\nplot!(p1, callback_results[:x1], label=L\"x_1\",minorticks=true,palette=:julia)\n\np2 = plot(\n    (1:127) ./ 127, callback_results[:lorenz][1],color=3, ls=:dash, label=\"Initial\",\n    minorticks=true,palette=:julia, legend_title=\"Lorenz curve\",\n    xlabel=\"Fraction of population\", ylabel=\"Fraction of wealth\",lw=2\n\n    )\nplot!(p2, (1:127) ./ 127 , callback_results[:lorenz][end],color=3, label=\"Final\", lw=2)\n\np = plot(p1, p2, layout=(2,1), size=(800, 600))\ndisplay(p)","category":"page"},{"location":"tutorials/using_callbacks/using_callbacks/","page":"Using callbacks","title":"Using callbacks","text":"(Image: EYSM Net Time Evolution)","category":"page"},{"location":"#YardSale.jl","page":"Home","title":"YardSale.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for YardSale.jl","category":"page"},{"location":"#WARNING","page":"Home","title":"WARNING","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"***–> This package is still under development <–***","category":"page"}]
}
